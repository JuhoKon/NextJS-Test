{"ast":null,"code":"import { Fragment as _Fragment } from \"react/jsx-runtime\";\nimport { jsxs as _jsxs } from \"react/jsx-runtime\";\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nimport { useRouter } from \"next/dist/client/router\";\nimport React from \"react\";\nimport Loading from \"../../../components/Loading\";\nimport { TestCall } from \"../../../lib/Api\";\n\nfunction sleep(ms) {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n\nexport const getStaticPaths = async () => {\n  return {\n    paths: [{\n      params: {\n        groupId: \"1\",\n        beaconId: \"1\"\n      }\n    }],\n    fallback: true\n  };\n};\nexport const getStaticProps = async ({\n  params\n}) => {\n  // Fetch data here for the pages according to the groupID and beaconID\n  // We can create a custom Error page that will be statically available, when the content is not found\n  // through error status returned from our BE\n  const json = await TestCall();\n  await sleep(3000);\n  return {\n    props: {\n      json,\n      params\n    },\n    // Re-generate the page at most per X seconds, if a request comes in\n    revalidate: 10\n  };\n};\n\nconst InfoTemplate = ({\n  params,\n  json\n}) => {\n  const router = useRouter();\n  console.log(params); //groupId, beaconId\n\n  if (router.isFallback) {\n    return /*#__PURE__*/_jsx(Loading, {});\n  }\n\n  return /*#__PURE__*/_jsxs(_Fragment, {\n    children: [/*#__PURE__*/_jsx(\"h1\", {\n      children: \"To be filled with content :-)\"\n    }), /*#__PURE__*/_jsxs(\"p\", {\n      children: [\"GroupId: \", params === null || params === void 0 ? void 0 : params.groupId]\n    }), /*#__PURE__*/_jsxs(\"p\", {\n      children: [\"BeaconId: \", params === null || params === void 0 ? void 0 : params.beaconId]\n    }), /*#__PURE__*/_jsxs(\"p\", {\n      children: [\"Current time in UNIX retrieved from API : \", json === null || json === void 0 ? void 0 : json.unixtime]\n    })]\n  });\n};\n\nexport default InfoTemplate;","map":null,"metadata":{},"sourceType":"module"}